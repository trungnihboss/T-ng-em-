<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Falling Text</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let w, h;
let texts = [];
let hearts = [];
let mouse = { x: 0, y: 0 };
let camera = { x: 0, y: 0 };
let textList = [
  "Always by my side", "1 Year Anniversary", "Lt.long♡Ha.phng",
  "Love u in every universe", "Dành cho em tia nắng ấm"
];

// Resize
function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// Generate text objects
function createTexts(count = 150) {
  texts = [];
  for (let i = 0; i < count; i++) {
    texts.push({
      text: textList[Math.floor(Math.random() * textList.length)],
      x: (Math.random() - 0.5) * 1000,
      y: Math.random() * -2000,
      z: Math.random() * 1000,
      size: 20 + Math.random() * 30,
      speed: 0.5 + Math.random() * 1.5
    });
  }
}

// Create hearts
function createHearts(count = 50) {
  hearts = [];
  for (let i = 0; i < count; i++) {
    hearts.push({
      x: (Math.random() - 0.5) * 1000,
      y: Math.random() * -2000,
      z: Math.random() * 1000,
      size: 10 + Math.random() * 10,
      speed: 0.3 + Math.random()
    });
  }
}

// Draw loop
function draw() {
  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.translate(w / 2, h / 2);

  const perspective = 500;

  // Texts
  texts.forEach(t => {
    t.y += t.speed;
    if (t.y > 1000) t.y = -2000;

    const scale = perspective / (perspective + t.z - camera.z);
    const x = (t.x - camera.x) * scale;
    const y = (t.y - camera.y) * scale;
    const opacity = Math.min(1, scale * 2);
    const fontSize = t.size * scale;

    ctx.font = `${fontSize}px sans-serif`;
    ctx.fillStyle = `rgba(255,192,203,${opacity})`;
    ctx.shadowColor = `rgba(255,192,203,${opacity})`;
    ctx.shadowBlur = 15 * scale;
    ctx.fillText(t.text, x, y);
  });

  // Hearts
  hearts.forEach(h => {
    h.y += h.speed;
    if (h.y > 1000) h.y = -2000;

    const scale = perspective / (perspective + h.z - camera.z);
    const x = (h.x - camera.x) * scale;
    const y = (h.y - camera.y) * scale;
    const size = h.size * scale;
    const opacity = Math.min(1, scale * 2);

    ctx.fillStyle = `rgba(255,0,0,${opacity})`;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x - size, y - size, x - size * 1.5, y + size, x, y + size * 1.5);
    ctx.bezierCurveTo(x + size * 1.5, y + size, x + size, y - size, x, y);
    ctx.fill();
  });

  ctx.restore();
  requestAnimationFrame(draw);
}

// Mouse controls for camera rotation
let lastX = 0;
let isDragging = false;

canvas.addEventListener("mousedown", e => {
  isDragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("mouseup", () => isDragging = false);
canvas.addEventListener("mousemove", e => {
  if (isDragging) {
    const deltaX = e.clientX - lastX;
    camera.x += deltaX * 1.5;
    lastX = e.clientX;
  }
});

// Touch support
canvas.addEventListener("touchstart", e => {
  lastX = e.touches[0].clientX;
});

canvas.addEventListener("touchmove", e => {
  const deltaX = e.touches[0].clientX - lastX;
  camera.x += deltaX * 1.5;
  lastX = e.touches[0].clientX;
});

createTexts(200);
createHearts(80);
draw();
</script>
</body>
</html>
