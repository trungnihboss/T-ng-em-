<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Fixed Text Effect</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: black;
    height: 100vh;
    user-select: none;
  }
  canvas {
    display: block;
    background: radial-gradient(ellipse at center, #000 0%, #010010 80%, #000 100%);
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let W, H;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  }
  window.addEventListener('resize', resize);
  resize();

  // Starry background
  const stars = [];
  const starCount = 150;
  for(let i=0; i<starCount; i++){
    stars.push({
      x: Math.random()*W,
      y: Math.random()*H,
      r: Math.random()*1.2,
      alpha: 0.3 + Math.random()*0.7,
      speed: 0.01 + Math.random()*0.02
    });
  }

  const lines = [
    "Anh Trung 💖Anh Thư",
    "You are like an angel that saved my soul😍",
    "I love you for no reason, because you are yourself!😘",
    "My heart sobs because of you!💘"
  ];

  let rotX = 0;
  let rotY = 0;
  let targetRotX = 0;
  let targetRotY = 0;

  let isDragging = false;
  let lastX, lastY;

  canvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  canvas.addEventListener('mouseup', e => { isDragging = false; });
  canvas.addEventListener('mouseleave', e => { isDragging = false; });
  canvas.addEventListener('mousemove', e => {
    if(!isDragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    targetRotY += dx * 0.002;
    targetRotX += dy * 0.002;
    targetRotX = Math.min(Math.max(targetRotX, -Math.PI/4), Math.PI/4);
    lastX = e.clientX;
    lastY = e.clientY;
  });

  canvas.addEventListener('touchstart', e => {
    if(e.touches.length === 1){
      isDragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }
  });
  canvas.addEventListener('touchend', e => { isDragging = false; });
  canvas.addEventListener('touchcancel', e => { isDragging = false; });
  canvas.addEventListener('touchmove', e => {
    if(!isDragging || e.touches.length !== 1) return;
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    targetRotY += dx * 0.002;
    targetRotX += dy * 0.002;
    targetRotX = Math.min(Math.max(targetRotX, -Math.PI/4), Math.PI/4);
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }, {passive:true});

  class TextParticle {
    constructor(text, x, y, z, layerIndex) {
      this.text = text;
      this.x = x;
      this.y = y;
      this.z = z;
      this.layerIndex = layerIndex;
      this.baseFontSize = 14 + layerIndex * 4;
    }
    rotate(rotX, rotY) {
      let cosY = Math.cos(rotY);
      let sinY = Math.sin(rotY);
      let x1 = this.x * cosY - this.z * sinY;
      let z1 = this.x * sinY + this.z * cosY;
      let cosX = Math.cos(rotX);
      let sinX = Math.sin(rotX);
      let y1 = this.y * cosX - z1 * sinX;
      let z2 = this.y * sinX + z1 * cosX;
      return {x: x1, y: y1, z: z2};
    }
  }

  const layersCount = 3;
  const particles = [];

  for(let layer=0; layer<layersCount; layer++){
    const depthZ = -50 + layer*40;
    const countPerLayer = 30;
    for(let i=0; i<countPerLayer; i++){
      const text = lines[i % lines.length];
      let x = -70 + Math.random()*140;
      let y = -60 + Math.random()*140;
      let z = depthZ + (Math.random()*20 - 10);
      particles.push(new TextParticle(text, x, y, z, layer));
    }
  }

  const focalLength = 250;

  function project(x, y, z) {
    const scale = focalLength / (focalLength + z);
    return {
      x: x * scale + W/2,
      y: y * scale + H/2,
      scale,
    };
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);

    // Draw stars
    for(let s of stars){
      s.alpha += s.speed * (Math.random() * 0.5);
      if(s.alpha > 1) s.alpha = 0.3;
      ctx.fillStyle = `rgba(255,255,255,${s.alpha.toFixed(2)})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }

    rotX += (targetRotX - rotX)*0.1;
    rotY += (targetRotY - rotY)*0.1;

    const sorted = particles.map(p => {
      const r = p.rotate(rotX, rotY);
      return {...p, rx: r.x, ry: r.y, rz: r.z};
    }).sort((a,b) => b.rz - a.rz);

    for(let p of sorted){
      const proj = project(p.rx, p.ry, p.rz);

      const opacity = Math.min(Math.max((p.rz + 70) / 120, 0), 1);
      const fontSize = p.baseFontSize * (0.7 + opacity * 0.6);

      ctx.font = `bold ${fontSize.toFixed(1)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      ctx.shadowColor = 'rgba(255, 182, 193, 0.7)';
      ctx.shadowBlur = 12;

      ctx.fillStyle = `rgba(255,105,180,${opacity.toFixed(2)})`;

      // Draw text fixed orientation (no rotation to face camera)
      ctx.fillText(p.text, proj.x, proj.y);

      ctx.shadowBlur = 0;
    }

    requestAnimationFrame(draw);
  }

  draw();

})();
</script>
</body>
</html>
